:icons: font

= Features

This section will be about the features of Gentics Mesh. Each will be described in detail including examples and references to relevant parts of the API or related tutorials.

[[contenttree]]

== Content Trees

Gentics Mesh provides the means to organize your contents in terms of a *content tree*, or rather a node tree. Nodes can be hierarchically structured if a container schema is provided.
For example, a book node can act as a container for chapter nodes. Alternatively, consider the example in our demo app, where vehicles are structured within categories.

While it is perfectly legitimate to organize your contents in a simple, flat structure with tagging and referencing, content trees come with big a bonus: they inherently allow for <<navigation,automatically generated hierarchical navigation menus>>, <<breadcrumbs,breadcrumbs>> and <<prettyurls,pretty URLs>>. This furthermore means routes are not hard-coded in your app but can be defined dynamically by content editors using the Gentics Mesh user interface.

TIP: To get you started, Gentics Mesh is shipped with a generic _folder_ schema allowing you to follow the well-known file system paradigm for hierarchically organizing your content in a tree.

There are two properties when defining a link:building-blocks.html#_schemas[schema] for your nodes that are of importance in this respect.

. ```container```: if true, nodes can contain child nodes and build a node tree.
. ```segmentField```: allows to specify which schema field should be considered the path segment for the current node, i.e., it’s the basis for building URLs.

[[example]]
Let us consider the following example on the basis of our demo app to demonstrate how these properties work together to support navigation menus, breadcrumbs and pretty URLs:

image::GenticsMesh-ContentTree-Example.png[Gentics Mesh Example of organizing content in a node tree,role="img-responsive"] 

Within the demo project vehicles are organized in three different categories. The nodes _Automobiles_, _Aircrafts_ and _Yachts_ of type _category_ serve as containers for nodes of type _vehicle_, e.g., the node _Ford GT_ in category _Automobiles_.

The schema _category_ has the ```container``` property set to ```true```, thus allowing nodes of type _category_ to have child nodes. The schema’s ```segmentField``` is specified to be the ```slug``` field. Thus, the resulting value for the ```path``` property of node _Automobiles_ is ```/automobiles```.

The schema _vehicle_ has the ```container``` property set to ```false```. The schema’s ```segmentField``` is again specified to be the ```slug``` field. Thus, the resulting value for the ```path``` property of node _Ford GT_ is ```/automobiles/ford-gt```.



[[prettyurls]]
== Pretty URLs

Instead of relying on UUIDs to link your content, you can use pretty URLs like https://yourapp.com/automobiles/ford-gt. For each node, Gentics Mesh will provide you with a human readable path. 
Likewise, you can query your content using WebRoot paths instead of using UUIDs (see <<webroot,WebRoot API>>).

The ```segmentField``` is used to build the path of a specific node. According to the nodes’ schemas in our <<example,example>>, the path ```/automobiles/ford-gt``` for the node _Ford GT_ is built using the _slug_ field of the _vehicle_ node, i.e. _Ford GT_, and the _slug_ field of the _category_ node, i.e. _Automobiles_.

image::GenticsMesh-PrettyURL-Example.png[Gentics Mesh Example for Building Pretty URLs,role="img-responsive"]

The ```path``` property as well as the ```languagesPath``` property (for available language variants) of a node can be queried using the ```/api/v1/projectName/nodes/:nodeUuid``` endpoint together with the query parameter ```resolveLinks```. Alternatively, the WebRoot API can be used ```/api/v1/:projectName/webroot/:path```
For more details see the documentation on link:building-blocks.html#_node[node] and <<webroot,WebRoot API>>, respectively.

==== API endpoints

[options="header",cols="2*"]
|======

| Description
| API endpoint

| Get the node with the given UUID.
| ```GET /api/v1/:projectName/nodes/:nodeUuid```

|======

==== Response Sample

.Try the example
[TIP]
https://demo.getmesh.io/api/v1/demo/nodes/fc3c85be82584ae2bc85be82588ae2b0?resolveLinks=short

[source,json]
----
{
  "uuid" : "fc3c85be82584ae2bc85be82588ae2b0",
  "creator" : {
    "uuid" : "a93e95f316114659be95f31611265997"
  },
  "created" : "2017-05-29T09:56:16Z",
  "editor" : {
    "uuid" : "a93e95f316114659be95f31611265997"
  },
  "edited" : "2017-05-29T09:56:22Z",
  "language" : "en",
  "availableLanguages" : [ "en" ],
  "languagePaths" : {
    "en" : "/automobiles/ford-gt"
  },
  "parentNode" : {
    "projectName" : "demo",
    "uuid" : "ca6c7df3f45b48d4ac7df3f45ba8d42f",
    "displayName" : "Automobiles",
    "path" : "/automobiles",
    "schema" : {
      "name" : "category",
      "uuid" : "2ca2362b041247c4a2362b041227c4da"
    }
  },
  "tags" : [ {
    "name" : "Gasoline",
    "uuid" : "1c51487f8e8043c291487f8e8053c2c1",
    "tagFamily" : "Fuels"
  }, {
    "name" : "Blue",
    "uuid" : "6e6f1d9f055447d2af1d9f055417d289",
    "tagFamily" : "Colors"
  }, {
    "name" : "White",
    "uuid" : "94fec98d6f114e81bec98d6f118e81cc",
    "tagFamily" : "Colors"
  } ],
  "project" : {
    "name" : "demo",
    "uuid" : "217f8c981ada4642bf8c981adaa642c3"
  },
  "childrenInfo" : { },
  "schema" : {
    "name" : "vehicle",
    "uuid" : "2aa83a2b3cba40a1a83a2b3cba90a1de",
    "version" : 1
  },
  "container" : false,
  "displayField" : "name",
  "fields" : {
    "slug" : "ford-gt",
    "name" : "Ford GT",
    "weight" : 1520,
    "SKU" : 1,
    "price" : 139995,
    "stocklevel" : 20,
    "description" : "The Ford GT is an American mid-engine two-seater sports car that was produced by Ford for the 2005 through 2006 model years.",
    "vehicleImage" : {
      "uuid" : "df8beb3922c94ea28beb3922c94ea2f6",
      "path" : "/images/ford-gt.jpg",
      "languagePaths" : {
        "en" : "/images/ford-gt.jpg"
      }
    }
  },
  "path" : "/automobiles/ford-gt",
  "breadcrumb" : [ {
    "projectName" : "demo",
    "uuid" : "ca6c7df3f45b48d4ac7df3f45ba8d42f",
    "displayName" : "Automobiles",
    "path" : "/automobiles",
    "schema" : {
      "name" : "category",
      "uuid" : "2ca2362b041247c4a2362b041227c4da"
    }
  } ],
  "version" : {
    "uuid" : "677bf76c8c624e2fbbf76c8c62be2fa0",
    "number" : "1.0"
  },
  "permissions" : {
    "create" : false,
    "read" : true,
    "update" : false,
    "delete" : false,
    "publish" : false,
    "readPublished" : false
  }
}
----

[[navigation]]
== Navigation Menus
When organizing your content in terms of a node tree, Gentics Mesh offers two ways of generating a nested navigation response.

The API endpoint ```/api/v1/:projectName/nodes/:nodeUuid/navigation``` returns a navigation object for the provided node, while the ```/api/v1/:projectName/navroot/:path``` API endpoint returns a navigation object for a node which is located using a given path.
Each endpoint will return a navigation response which contains the nested navigation tree structure.

By default, only container nodes are included in a navigation response. The `includeAll` query parameter will include all nodes, if set to `true`.
The `maxDepth` parameter may be used to limit the navigation depth. In order to include the `path` property in the navigation response, the `resolveLinks` query parameter can be used.

image::GenticsMesh-Navigation-Example.png[Gentics Mesh Example for Building Navigation Menus,role="img-responsive"]

The demo app includes a navigation object showing just the top-level elements _Automobiles_, _Aircraft_, and _Yachts_ as well as the _Home_ link. All the elements can be easily queried using the available navigation endpoints. In particular, the example uses the ```/api/v1/:projectName/navroot/:path``` API endpoint, with the URL parameter ```:path``` querying the project root node, i.e., ```/``` together with query parameter ```?maxDepth``` limiting the resulting nested JSON object to the top-level nodes.


=== API endpoints

[options="header",cols="2*"]
|======

| Description
| API endpoint

| Returns a navigation object for the provided node.
| ```GET /api/v1/:projectName/nodes/:nodeUuid/navigation```

| Return a navigation for the node which is located using the given path.
| ```GET /api/v1/:projectName/navroot/:path```

|======

=== Properties
[options="header",cols="3*"]
|======

| Name
| Type
| Description

| node
| object
| Detailed node information of the given UUID.

| children
| array
| List of further child elements of the node.

| uuid
| string
| UUID of the node within this navigation element.
|======

=== Query Parameters
[options="header",cols="3*"]
|======

| Name
| Type
| Description

| includeAll
| boolean (default: false)
| If set to true all nodes will be included in the response. By default only container nodes are included in a navigation response.

| maxDepth
| number (default: 10)
| Specifies the maximum depth for the requested navigation tree structure.

| lang
| string
| The ISO 639-1 language tag of the language which should be loaded. Fallback handling can be applied by specifying multiple languages in a comma-separated list. The first matching language will be returned. If omitted or the requested language is not available then the ```defaultLanguage``` as configured in ```mesh.yml``` will be returned.

| release
| string
| Specifies the release UUID to be used for loading data. The latest project release will be used if this parameter is omitted.

| resolveLinks
| string
| The ```resolveLinks``` parameter can be set to either ```short```, ```medium``` or ```full```. Links will automatically be resolved and replaced by the resolved  link:features.html#_link_resolving[WebRoot path]. No resolving occurs if the query parameter is omitted.

| role
| string
| The ```role``` query parameter takes a UUID and may be used in order to add permission information to the response which is related to the specified role. When used, the response will include the ```rolePerms``` property which lists the permissions for the specified role on this node. E.g., this may be useful when you are logged in as administrator but want to retrieve the editor role permissions on a given node.

| version
| string
| Specifies the version of the node’s language variant, e.g.: ```0.1```, ```1.0```, ```draft```, ```published```.

|======

=== Response Sample

Retrieving a navigation object using the projects root node ```/``` including the top level navigation menu items.

.Try the example
[TIP]
https://demo.getmesh.io/api/v1/demo/navroot/?resolveLinks=short&maxDepth=1

The same can be achieved using the node specific navigation endpoint. In this case you can specify the root node of your navigation by providing the node uuid.

.Try the example
[TIP]
https://demo.getmesh.io/api/v1/demo/nodes/72dbee3975054fce9bee397505cfcec5/navigation?resolveLinks=short&maxDepth=1

[source,json]
----
{
  "uuid" : "72dbee3975054fce9bee397505cfcec5",
  "node" : {
    "uuid" : "72dbee3975054fce9bee397505cfcec5",
    "creator" : {
      "uuid" : "a93e95f316114659be95f31611265997"
    },
    "created" : "2017-05-29T09:55:43Z",
    "editor" : {
      "uuid" : "a93e95f316114659be95f31611265997"
    },
    "edited" : "2017-05-29T09:56:22Z",
    "language" : "en",
    "availableLanguages" : [ "en" ],
    "languagePaths" : {
      "en" : "/"
    },
    "tags" : [ ],
    "project" : {
      "name" : "demo",
      "uuid" : "217f8c981ada4642bf8c981adaa642c3"
    },
    "childrenInfo" : {
      "folder" : {
        "schemaUuid" : "5cc780af998c4d228780af998ccd2240",
        "count" : 1
      },
      "category" : {
        "schemaUuid" : "2ca2362b041247c4a2362b041227c4da",
        "count" : 3
      }
    },
    "schema" : {
      "name" : "folder",
      "uuid" : "5cc780af998c4d228780af998ccd2240",
      "version" : 1
    },
    "container" : true,
    "displayField" : "name",
    "fields" : { },
    "path" : "/",
    "breadcrumb" : [ ],
    "version" : {
      "uuid" : "df10370c82be422290370c82be62229f",
      "number" : "1.0"
    },
    "permissions" : {
      "create" : false,
      "read" : true,
      "update" : false,
      "delete" : false,
      "publish" : false,
      "readPublished" : false
    }
  },
  "children" : [ {
    "uuid" : "15d5ef7a9abf416d95ef7a9abf316d68",
    "node" : {
      "uuid" : "15d5ef7a9abf416d95ef7a9abf316d68",
      "creator" : {
        "uuid" : "a93e95f316114659be95f31611265997"
      },
      "created" : "2017-05-29T09:56:10Z",
      "editor" : {
        "uuid" : "a93e95f316114659be95f31611265997"
      },
      "edited" : "2017-05-29T09:56:22Z",
      "language" : "en",
      "availableLanguages" : [ "en" ],
      "languagePaths" : {
        "en" : "/images"
      },
      "parentNode" : {
        "projectName" : "demo",
        "uuid" : "72dbee3975054fce9bee397505cfcec5",
        "path" : "/",
        "schema" : {
          "name" : "folder",
          "uuid" : "5cc780af998c4d228780af998ccd2240"
        }
      },
      "tags" : [ ],
      "project" : {
        "name" : "demo",
        "uuid" : "217f8c981ada4642bf8c981adaa642c3"
      },
      "childrenInfo" : {
        "vehicleImage" : {
          "schemaUuid" : "b12272150db4490ea272150db4190e72",
          "count" : 10
        }
      },
      "schema" : {
        "name" : "folder",
        "uuid" : "5cc780af998c4d228780af998ccd2240",
        "version" : 1
      },
      "container" : true,
      "displayField" : "name",
      "fields" : {
        "slug" : "images",
        "name" : "Vehicle Images"
      },
      "path" : "/images",
      "breadcrumb" : [ ],
      "version" : {
        "uuid" : "b1f2c06e45db4e0db2c06e45dbfe0d25",
        "number" : "1.0"
      },
      "permissions" : {
        "create" : false,
        "read" : true,
        "update" : false,
        "delete" : false,
        "publish" : false,
        "readPublished" : false
      }
    }
  }, {
    "uuid" : "ca6c7df3f45b48d4ac7df3f45ba8d42f",
    "node" : {
      "uuid" : "ca6c7df3f45b48d4ac7df3f45ba8d42f",
      "creator" : {
        "uuid" : "a93e95f316114659be95f31611265997"
      },
      "created" : "2017-05-29T09:56:16Z",
      "editor" : {
        "uuid" : "a93e95f316114659be95f31611265997"
      },
      "edited" : "2017-05-29T09:56:22Z",
      "language" : "en",
      "availableLanguages" : [ "en" ],
      "languagePaths" : {
        "en" : "/automobiles"
      },
      "parentNode" : {
        "projectName" : "demo",
        "uuid" : "72dbee3975054fce9bee397505cfcec5",
        "path" : "/",
        "schema" : {
          "name" : "folder",
          "uuid" : "5cc780af998c4d228780af998ccd2240"
        }
      },
      "tags" : [ ],
      "project" : {
        "name" : "demo",
        "uuid" : "217f8c981ada4642bf8c981adaa642c3"
      },
      "childrenInfo" : {
        "vehicle" : {
          "schemaUuid" : "2aa83a2b3cba40a1a83a2b3cba90a1de",
          "count" : 5
        }
      },
      "schema" : {
        "name" : "category",
        "uuid" : "2ca2362b041247c4a2362b041227c4da",
        "version" : 1
      },
      "container" : true,
      "displayField" : "name",
      "fields" : {
        "name" : "Automobiles",
        "slug" : "automobiles"
      },
      "path" : "/automobiles",
      "breadcrumb" : [ ],
      "version" : {
        "uuid" : "2cadceaea20343e8adceaea20313e842",
        "number" : "1.0"
      },
      "permissions" : {
        "create" : false,
        "read" : true,
        "update" : false,
        "delete" : false,
        "publish" : false,
        "readPublished" : false
      }
    }
  }, {
    "uuid" : "21203632520b4d19a03632520b2d19c1",
    "node" : {
      "uuid" : "21203632520b4d19a03632520b2d19c1",
      "creator" : {
        "uuid" : "a93e95f316114659be95f31611265997"
      },
      "created" : "2017-05-29T09:56:19Z",
      "editor" : {
        "uuid" : "a93e95f316114659be95f31611265997"
      },
      "edited" : "2017-05-29T09:56:22Z",
      "language" : "en",
      "availableLanguages" : [ "en" ],
      "languagePaths" : {
        "en" : "/aircrafts"
      },
      "parentNode" : {
        "projectName" : "demo",
        "uuid" : "72dbee3975054fce9bee397505cfcec5",
        "path" : "/",
        "schema" : {
          "name" : "folder",
          "uuid" : "5cc780af998c4d228780af998ccd2240"
        }
      },
      "tags" : [ ],
      "project" : {
        "name" : "demo",
        "uuid" : "217f8c981ada4642bf8c981adaa642c3"
      },
      "childrenInfo" : {
        "vehicle" : {
          "schemaUuid" : "2aa83a2b3cba40a1a83a2b3cba90a1de",
          "count" : 3
        }
      },
      "schema" : {
        "name" : "category",
        "uuid" : "2ca2362b041247c4a2362b041227c4da",
        "version" : 1
      },
      "container" : true,
      "displayField" : "name",
      "fields" : {
        "name" : "Aircraft",
        "slug" : "aircrafts"
      },
      "path" : "/aircrafts",
      "breadcrumb" : [ ],
      "version" : {
        "uuid" : "cb34cedeeb9c4d3db4cedeeb9c0d3d01",
        "number" : "1.0"
      },
      "permissions" : {
        "create" : false,
        "read" : true,
        "update" : false,
        "delete" : false,
        "publish" : false,
        "readPublished" : false
      }
    }
  }, {
    "uuid" : "eb2ebdcc0e894a9eaebdcc0e896a9e1d",
    "node" : {
      "uuid" : "eb2ebdcc0e894a9eaebdcc0e896a9e1d",
      "creator" : {
        "uuid" : "a93e95f316114659be95f31611265997"
      },
      "created" : "2017-05-29T09:56:21Z",
      "editor" : {
        "uuid" : "a93e95f316114659be95f31611265997"
      },
      "edited" : "2017-05-29T09:56:22Z",
      "language" : "en",
      "availableLanguages" : [ "en" ],
      "languagePaths" : {
        "en" : "/yachts"
      },
      "parentNode" : {
        "projectName" : "demo",
        "uuid" : "72dbee3975054fce9bee397505cfcec5",
        "path" : "/",
        "schema" : {
          "name" : "folder",
          "uuid" : "5cc780af998c4d228780af998ccd2240"
        }
      },
      "tags" : [ ],
      "project" : {
        "name" : "demo",
        "uuid" : "217f8c981ada4642bf8c981adaa642c3"
      },
      "childrenInfo" : {
        "vehicle" : {
          "schemaUuid" : "2aa83a2b3cba40a1a83a2b3cba90a1de",
          "count" : 2
        }
      },
      "schema" : {
        "name" : "category",
        "uuid" : "2ca2362b041247c4a2362b041227c4da",
        "version" : 1
      },
      "container" : true,
      "displayField" : "name",
      "fields" : {
        "name" : "Yachts",
        "slug" : "yachts"
      },
      "path" : "/yachts",
      "breadcrumb" : [ ],
      "version" : {
        "uuid" : "4bc10d889134438e810d889134038ed9",
        "number" : "1.0"
      },
      "permissions" : {
        "create" : false,
        "read" : true,
        "update" : false,
        "delete" : false,
        "publish" : false,
        "readPublished" : false
      }
    }
  } ]
}
----

== Breadcrumbs

Each node in Gentics Mesh provides information on where it is located within the node tree in terms of its ```breadcrumb``` property.
The property provides an array of node references representing the path from the current node up to the project root. For more details see the documentation on link:building-blocks.html#_node[node].

NOTE: The current node will not be included in the list, since all the information is already provided in other properties (i.e., ```displayField```, ```path```) of node object itself.

In our demo app example, the ```breadcrumb``` property for node _Ford GT_ will therefore include the node _Automobiles_.

image::GenticsMesh-Breadcrumb-Example.png[Gentics Mesh Example for Building Breadcumbs,role="img-responsive"]

The ```breadcrumb``` property will be returned in all API responses containing nodes. Using the ```resolveLink``` query parameter will also the paths of the nodes listed in the array.

=== API endpoints

[options="header",cols="2*"]
|======

| Description
| API endpoint

| Get all nodes of a project and return a paged list response.
| ```GET /api/v1/projectName/nodes```

| Get the node with the given UUID.
| ```GET /api/v1/:projectName/nodes/:nodeUuid```

| Load the node or the node's binary data, which is located using the provided path.
| ```GET /api/v1/:projectName/webroot/:path```

|======

=== Response Sample

.Try the example
[TIP]
https://demo.getmesh.io/api/v1/demo/nodes/fc3c85be82584ae2bc85be82588ae2b0?resolveLinks=short

[source,json]
----
{
  "uuid" : "fc3c85be82584ae2bc85be82588ae2b0",
  "creator" : {
    "uuid" : "a93e95f316114659be95f31611265997"
  },
  "created" : "2017-05-29T09:56:16Z",
  "editor" : {
    "uuid" : "a93e95f316114659be95f31611265997"
  },
  "edited" : "2017-05-29T09:56:22Z",
  "language" : "en",
  "availableLanguages" : [ "en" ],
  "languagePaths" : {
    "en" : "/automobiles/ford-gt"
  },
  "parentNode" : {
    "projectName" : "demo",
    "uuid" : "ca6c7df3f45b48d4ac7df3f45ba8d42f",
    "displayName" : "Automobiles",
    "path" : "/automobiles",
    "schema" : {
      "name" : "category",
      "uuid" : "2ca2362b041247c4a2362b041227c4da"
    }
  },
  "tags" : [ {
    "name" : "Gasoline",
    "uuid" : "1c51487f8e8043c291487f8e8053c2c1",
    "tagFamily" : "Fuels"
  }, {
    "name" : "Blue",
    "uuid" : "6e6f1d9f055447d2af1d9f055417d289",
    "tagFamily" : "Colors"
  }, {
    "name" : "White",
    "uuid" : "94fec98d6f114e81bec98d6f118e81cc",
    "tagFamily" : "Colors"
  } ],
  "project" : {
    "name" : "demo",
    "uuid" : "217f8c981ada4642bf8c981adaa642c3"
  },
  "childrenInfo" : { },
  "schema" : {
    "name" : "vehicle",
    "uuid" : "2aa83a2b3cba40a1a83a2b3cba90a1de",
    "version" : 1
  },
  "container" : false,
  "displayField" : "name",
  "fields" : {
    "slug" : "ford-gt",
    "name" : "Ford GT",
    "weight" : 1520,
    "SKU" : 1,
    "price" : 139995,
    "stocklevel" : 20,
    "description" : "The Ford GT is an American mid-engine two-seater sports car that was produced by Ford for the 2005 through 2006 model years.",
    "vehicleImage" : {
      "uuid" : "df8beb3922c94ea28beb3922c94ea2f6",
      "path" : "/images/ford-gt.jpg",
      "languagePaths" : {
        "en" : "/images/ford-gt.jpg"
      }
    }
  },
  "path" : "/automobiles/ford-gt",
  "breadcrumb" : [ {
    "projectName" : "demo",
    "uuid" : "ca6c7df3f45b48d4ac7df3f45ba8d42f",
    "displayName" : "Automobiles",
    "path" : "/automobiles",
    "schema" : {
      "name" : "category",
      "uuid" : "2ca2362b041247c4a2362b041227c4da"
    }
  } ],
  "version" : {
    "uuid" : "677bf76c8c624e2fbbf76c8c62be2fa0",
    "number" : "1.0"
  },
  "permissions" : {
    "create" : false,
    "read" : true,
    "update" : false,
    "delete" : false,
    "publish" : false,
    "readPublished" : false
  }
}
----

[[webroot]]
== Fetch Content with WebRoot Paths

The WebRoot API is an alternative way for fetching content from Gentics Mesh. Other than accessing nodes with their UUID, one can use the way more intuitive WebRoot paths.

image::GenticsMesh-WebRootAPI-Example.png[Gentics Mesh Example for Fetching Content by Path using the WebRoot API,role="img-responsive"]

This functionality builds on top of using the nodes' ```segmentField``` property to build the path of a specific node.
WebRoot paths of arbitrary depth can be created, in combination with organizing content hierarchically in terms of a <<contenttree,content tree>> by specifying nodes to be ```containers``` for their child nodes.
The WebRoot API endpoint uses this information to resolve a given path to a node UUID.

Using the WebRoot API it is possible to easily integrate Gentics Mesh with many known routing frameworks.

[options="header"]
|======
| Framework                           | Language       | Example
| http://silex.sensiolabs.org/[Silex] | PHP            | https://getmesh.io/Blog/Building+an+API-first+Web+App+with+Gentics+Mesh+and+the+PHP+Microframework+Silex[Blogpost]
| http://expressjs.com/[ExpressJS]    | JS             | https://getmesh.io/Blog/Getting+started+with+Express+and+the+API-first+CMS+Gentics+Mesh[Blogpost]
| http://vertx.io/[Vert.x]            | Java,JS,Ceylon | http://vertx.io/blog/data-driven-apps-made-easy-with-vert-x-3-4-0-and-headless-cms-gentics-mesh/[Blogpost]
| http://lotusrb.org/[Lotus]          | Ruby           | -
|======

//TODO Blogpost on WebRoot API

=== API endpoints

[options="header",cols="2*"]
|======

| Description
| API endpoint

| Load the node or the node's binary data, which is located using the provided path.
| ```GET /api/v1/:projectName/webroot/:path```

|======

=== Query content by path

A WebRoot path may consist of multiple path segments, each corresponding to a node within the content tree. The ```segmentField``` property from the schema is used to determine the node's relevant field value.

NOTE: Each segment of the URL must be URL-encoded. A node's language variants must provide different path segment in order to guarantee unique paths.

==== Fetch node with UUID

.Try the example
[TIP]
https://demo.getmesh.io/api/v1/demo/nodes/fc3c85be82584ae2bc85be82588ae2b0?resolveLinks=short

Loading the node with the given UUID using API endpoint ```GET /api/v1/:projectName/nodes/:nodeUuid```.

==== Fetch node with WebRoot path

.Try the example
[TIP]
https://demo.getmesh.io/api/v1/demo/webroot/automobiles/ford-gt?resolveLinks=short

=== Query binary content by path
The WebRoot API, furthermore, directly supports delivering binary content using the ```fileName``` meta-data field of the ```binary``` field .

==== Fetch an image with UUID

> https://demo.getmesh.io/api/v1/demo/nodes/df8beb3922c94ea28beb3922c94ea2f6/binary/image

Downloading a node's binary field with the given name using API endpoint ```GET /api/v1/:projectName/nodes/:nodeUuid/binary/:fieldName```.

==== Fetch an image with WebRoot path

.Try the example
[TIP]
https://demo.getmesh.io/api/v1/demo/webroot/images/ford-gt.jpg

TIP: When using a routing framework, in order to find out if a requested resource is binary data or JSON data you need to check the HTTP Content-Disposition response header. If it is set, it’s binary data.

=== Image manipulation by path
In case, the binary data is an image, the WebRoot API allows to directly perform <<imagemanipulation, image manipulation>> such as cropping and resizing.

==== Crop and resize an image with UUID

.Try the example
[TIP]
https://demo.getmesh.io/api/v1/demo/nodes/df8beb3922c94ea28beb3922c94ea2f6/binary/image?cropx=10&cropy=100&cropw=800&croph=400&width=300

==== Crop and resize an image with WebRoot path

.Try the example
[TIP]
https://demo.getmesh.io/api/v1/demo/webroot/images/ford-gt.jpg?cropx=10&cropy=100&cropw=800&croph=400&width=300

Find out more about this topic in our blogpost about https://getmesh.io/Blog/Gentics+Mesh%27s+Image+Manipulation+API+and+Interface[Gentics Mesh's Image Manipulation API and Interface].

=== Properties
//TODO

=== Query Parameters

==== Paging Parameters

include::examples/tables/PagingParametersImpl.adoc[]

==== Versioning Parameters

include::examples/tables/VersioningParametersImpl.adoc[]

===== Node Parameters

include::examples/tables/NodeParametersImpl.adoc[]

===== Role Permission Parameters

include::examples/tables/RolePermissionParametersImpl.adoc[]

== Link Resolving

Link resolving represents the counterpart of the <<webroot, WebRoot API>> - a node UUID can be resolved into a WebRoot path.

image::GenticsMesh-LinkResolver-Utility-Example.png[Gentics Mesh Example for automatically Resolving Links,role="img-responsive"]

Typically, editors create content including internal links to other nodes. When fetching content for your apps, however, Gentics Mesh will resolve these internal links for you and return a WebRoot path.

For example, ```{{mesh.link("2f2de9297c8143e8ade9297c8193e8fc", "en")}}``` will be transformed into ```/api/v1/demo/webroot/images/ford-gt.jpg``` when using the ```?resolveLinks=full``` query parameter.

The ```?resolveLinks``` query parameter defines if and how links are resolved:

* `off` -  links will not be resolved. This is the default.
* `full` - the resolved links will contain the WebRoot prefix and project name (```/api/v1/:projectName/webRoot/:path```).
* `medium` - the resolved links will contain the project name (```/:projectName/:path```).
* `short` - will contain neither WebRoot prefix nor project name, just the path (```:path```).

The ```?resolveLinks``` query parameter can be applied to all API endpoints returning nodes.

=== API endpoints

[options="header",cols="2*"]
|======

| Description
| API endpoint

| Get all nodes of a project and return a paged list response.
| ```GET /api/v1/projectName/nodes```

| Get the node with the given UUID.
| ```GET /api/v1/:projectName/nodes/:nodeUuid```

| Load the node or the node's binary data, which is located using the provided path.
| ```GET /api/v1/:projectName/webroot/:path```

| Get a navigation object for the provided node.
| ```GET /api/v1/:projectName/nodes/:nodeUuid/navigation```

| Return a navigation for the node which is located using the given path.
| ```GET /api/v1/:projectName/navroot/:path```

|======

=== Link Resolver Utility

In addition to the above, Gentics Mesh offers the ```/api/v1/utilities/linkResolver``` endpoint that can be used to resolve Gentics Mesh links within the posted text data. This is useful when resolving links for a preview page.

It’s necessary to send the content in which links should get resolved to the API endpoint in plain text or JSON. The query parameter ```?resolveLinks``` is used to specify how links shall be resolved.

Valid links:

 * {{mesh.link("2f2de9297c8143e8ade9297c8193e8fc", "en")}}

* {{mesh.link('2f2de9297c8143e8ade9297c8193e8fc', 'en')}}

* {{mesh.link(\"2f2de9297c8143e8ade9297c8193e8fc\", \"en\")}}

* {{mesh.link("2f2de9297c8143e8ade9297c8193e8fc")}} (link to default language)


[[imagemanipulation]]
== Image Manipulation

Images can be resized and/or cropped by appending the <<imagemanipulationparams,image manipulation query parameters>> on the relevant API endpoints.


=== Fetch and Resize an Image with UUID

Endpoint: ```/api/v1/:projectName/nodes/:uuid/binary/:fieldname?width=220```

.Try the example
[TIP]
https://demo.getmesh.io/api/v1/demo/nodes/df8beb3922c94ea28beb3922c94ea2f6/binary/image?width=300

=== Fetch and Crop an Image with WebRoot Path

It is also possible to use the image manipulation in combination with the WebRoot endpoint.

Endpoint: ```/api/v1/:projectName/webroot/:path?cropx=10&cropy=100&cropw=800&croph=400```

.Try the example
[TIP]
https://demo.getmesh.io/api/v1/demo/webroot/images/ford-gt.jpg?cropx=10&cropy=100&cropw=800&croph=400

NOTE: It is mandatory to specify all four crop parameters when cropping an image.

=== Transform and Update an Image

Gentics Mesh also allows you to transform (i.e, crop and/or resize) and overwrite an image in a single step. The image manipulation parameters then are part of the request body.

Endpoint: ```POST /api/v1/:projectName/nodes/:uuid/binaryTransform/:fieldname```

.Try the example
[TIP]
https://demo.getmesh.io/api/v1/demo/nodes/df8beb3922c94ea28beb3922c94ea2f6/binaryTransform/image

*Request Body:*
[source,bash]
----
{
  "version" : {
    "number" : "1.0"
  },
  "language" : "en",
  "width" : 300
}
----

[imagemanipulationparams]
=== Image Manipulation Query Parameters

include::examples/tables/ImageManipulationParametersImpl.adoc[]

Find out more about this topic in our blogpost about https://getmesh.io/Blog/Gentics+Mesh%27s+Image+Manipulation+API+and+Interface[Gentics Mesh's Image Manipulation API and Interface].

== File Upload

Binary data can be attached to node binary fields. The ```/api/v1/nodes/:uuid/binary/:fieldName``` endpoint can be used to POST binary data and thus update the stored binary field.

NOTE: This endpoint is accepting ```multipart/form-data```, only.

It is required to specify the `version` and `language` within the update request. This is similar to regular node update requests in which these information must be added to the JSON object.

```
----------Geg2Oob
Content-Disposition: form-data; name="version"

1.0

----------Geg2Oob
Content-Disposition: form-data; name="language"

en

----------Geg2Oob
Content-Disposition: form-data; name="shohY6d"; filename="somefile.bin"
Content-Type: application/octet-stream
Content-Transfer-Encoding: binary

fileData

----------Geg2Oob--
```

=== Configuration

Gentics Mesh stores all binary files on the filesystem. The default directory ```data/binaryfiles``` can be changed in the upload section of the main configuration file ```mesh.yml```.

The upload limit can be configured in bytes using the ```uploadOptions.byteLimit``` setting.

For more information on available settings have a look at the link:administration-guide.html#_settings[administration guide].

[[multilanguage]]
== Multi-Language

Gentics Mesh comes with multi-language support out of the box. In particular, a node serves as a container for one or more language variants. These language variants will store the actual content fields.

You can query individual language variants by appending the ```?lang``` query parameter. The ```language``` json property within an update or create request will be used to identify which language variant should be created or updated.

Requests for nodes should contain the requested languages (as comma separated list)as query parameter:

Endpoint: ```/api/v1/:projectName/nodes/:uuid?lang=en,de```

If the requested node is available in any of the languages, the response will contain the fields in that language (first language found).

=== Language Fallback

Gentics Mesh allows to configure a ```defaultLanguage``` in the main configuration file ```mesh.yml```. This default language is used as a fallback in case:

. the ```lang``` query parameter has been omitted, or
. the requested content is not available in the specified language.

This fallback mechanism works when fetching nodes but also when requesting navigation objects or breadcrumb information.

NOTE: In order to work properly, the fallback mechanism requires all nodes to have a language variant for the specified ```defaultLanguage```.

== Permissions

=== Overview

Permissions allow to equip different groups of users with access to content of your project. 

In Gentics Mesh, we distinguish the concepts of 
link:building-blocks.html#_user[user], link:building-blocks.html#_group[group], and link:building-blocks.html#_role[role] for managing different needs of access.

* A user represents a physical person or a client app that needs to interact with your contents.
* Groups are used to gather users of same content needs and access levels, e.g. administrators, editors, and users of your app. 
* A role describes a set of permissions on other elements in Gentics Mesh, e.g. nodes, tags, schemas, users.

By assigning a role to a group, the role's permissions are efficiently granted to a set of users.

NOTE: For reasons of readability, we will describe granting permissions to users though technically, permissions are granted to a specific role and applied to users via groups. 

// TODO image (anonymous, and other roles having different permissions)



[caption=]
.Permissions in Gentics Mesh
[options="header"]
|======
| Permission    | Description
| create        | grants the right to create instances of the element
| read          | grants read access to the element
| update        | grants the right to update the element
| delete        | grants the right to delete the element
| publish       | grants the right to publish/unpublish a node
| readPublished | grants the right to read the published version of the node
|======

NOTE: The ```publish``` and ```readPublish``` permissions are specifically available for node elements.

Most API responses within Gentics Mesh contain a list of permissions. This list indicates which permissions have been granted on the returned element(s) to the requesting user.

==== Example

.Try the example
[TIP]
https://demo.getmesh.io/api/v1/demo/nodes/fc3c85be82584ae2bc85be82588ae2b0?version=published
// TODO provide new example node, remove read permission for this example node only, add ?version=published to example code


[source,json]
-----
// permissions for node https://demo.getmesh.io/api/v1/demo/nodes/fd58237c79d64bf198237c79d6bbf107?version=published
...
  "permissions" : {
    "create" : false,        //create other nodes
    "read" : false,          //read all versions of the node 
    "update" : false,        //update the node
    "delete" : false,        //delete the node
    "publish" : false,       //publish or unpublish the node
    "readPublished" : true   //read the published version of the node
  }
...  
-----

The example above shows that the requesting user ```anonymous``` has the ```readPublish``` permission on the requested node, only. This means the user is allowed to read the published version of the node but not previous versions or a draft version of the requested element.

Furthermore the user is not allowed to

* ```create``` child nodes
* ```read``` a draft version of the node
* ```update``` the requested node
* ```delete``` the requested node
* ```publish``` a draft version of the requested node, or ```unpublish``` a node.

IMPORTANT: Gentics Mesh by default returns the ```draft``` version of nodes. This means for supporting the ```anonymous``` user and public content, you need to add the ```?version=published``` query parameter on all requests for nodes to avoid _"Missing permissions on object"_ errors. Find out more in the <<versioning,Versioning>> section.


Following, we will discuss how to query, assign and revoke permissions in Gentics Mesh including the available API endpoints.

[caption=]
.API endpoints for querying, assigning, and revoking permissions
[options="header",cols="2*"]
|======

| Description
| API endpoint

| Read the user permissions on the element that can be located by the specified path.
| link:raml/#users__userUuid__permissions__path__get[```GET /api/v1/users/:userUuid/permissions/:path```]

| Load the permissions between given role and the targeted element.
| link:raml/#roles__roleUuid__permissions__pathToElement__get[```GET /api/v1/roles/:roleUuid/permissions/:path```]

| Set the permissions between role and the targeted element.
| link:raml#roles__roleUuid__permissions__pathToElement__post[```POST /api/v1/roles/:roleUuid/permissions/:path```]

|======

=== Querying Permissions

There are dedicated API endpoints for querying permissions on elements.

NOTE: The following example links, require prior authentication with user ```admin``` (credentials: admin/admin). Please refer to the link:references.html#_authentication[authentication section] to learn about the different authentication mechanisms provided by Gentics Mesh. The https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en[Postman] Chrome extension can be used to build and invoke requests from your browser to Gentics Mesh.

==== Querying Role Permissions
The link:raml/#roles__roleUuid__permissions__pathToElement__get[```GET /api/v1/roles/:roleUuid/permissions/:path```] endpoint can be used to query a role's permission on a specific element or set of elements.

For example, the link:references.html#_authentication[authenticated] ```admin``` user is able to find out the configured permissions for role ```anonymous``` on node ```fc3c85be82584ae2bc85be82588ae2b0```.

.Try the example with user ```admin```
[TIP]
https://demo.getmesh.io/api/v1/roles/10447951fd264e6a847951fd266e6ae6/permissions/projects/217f8c981ada4642bf8c981adaa642c3/nodes/88fac3fbc61041c1bac3fbc610d1c182
Note, that a request with user ```anonymous``` will yield a _Missing object permissions_ error response.


[source,bash]
-----
GET https://demo.getmesh.io/api/v1/roles/10447951fd264e6a847951fd266e6ae6/permissions/projects/217f8c981ada4642bf8c981adaa642c3/nodes/88fac3fbc61041c1bac3fbc610d1c182

RESPONSE
{
    "create": false,
    "read": false,
    "update": false,
    "delete": false,
    "publish": false,
    "readPublished": true
} 
-----

Alternatively, you can use query the element using the respective API endpoint (e.g. link:++raml#project__nodes__get++[```GET /api/v1/projectName/nodes```]) and use the ```role``` query parameter to find out another role's (i.e. ```anonymous```) permissions on the element:

.Try the example with user ```admin```
[TIP]
https://demo.getmesh.io/api/v1/demo/nodes/88fac3fbc61041c1bac3fbc610d1c182?role=10447951fd264e6a847951fd266e6ae6

[source,bash]
-----
GET https://demo.getmesh.io/api/v1/roles/10447951fd264e6a847951fd266e6ae6/permissions/projects/217f8c981ada4642bf8c981adaa642c3/nodes/88fac3fbc61041c1bac3fbc610d1c182

RESPONSE
...
  "permissions" : { // permissions of requesting user admin
    "create" : true,
    "read" : true,
    "update" : true,
    "delete" : true,
    "publish" : true,
    "readPublished" : true
  },
  "rolePerms" : { // permissions of requested role anonymous
    "create" : false,
    "read" : false,
    "update" : false,
    "delete" : false,
    "publish" : false,
    "readPublished" : true
  }
  ...
-----

==== Querying User Permissions
The endpoint link:raml/#users__userUuid__permissions__path__get[```GET /api/v1/users/:userUuid/permissions/:path```] provides a shortcut for querying permissions for specific users directly, e.g., for user ```anonymous```, which is essentially inheriting all permissions from role ```anonymous```.

.Try the example
[TIP]
https://demo.getmesh.io/api/v1/users/5fb9654c0b734e87b9654c0b736e8701/permissions/projects/217f8c981ada4642bf8c981adaa642c3/nodes/88fac3fbc61041c1bac3fbc610d1c182

=== Assigning & Revoking Permissions 

The link:raml#roles__roleUuid__permissions__pathToElement__post[```POST /api/v1/roles/:roleUuid/permissions/:path```] API endpoint can be used to assign or revoke permissions to/from a role. 

* It is important to note that permissions can be granted on individual elements and onto a set of elements, which is identified by the element path name (e.g.: ```/users/:uuid``` and ```/users```).

* Furthermore, the endpoint offers the property ```recursive``` for applying permissions recursively on child elements.

//COMMENT: This info is interesting for mesh developers, not mesh API users.
//In order to ensure that roles are able to invoke CRUD operations on objects they have created or would have been able to create in the first place, CRUD permissions are assigned to those roles. 

//This is demonstrated by the following example:  

//* User John is assigned to Role A. Role A grants him to create a new child Node in a parent Node.
//* User Mary is assigned to Role B. Role B grants her to also create a new child //Node in the same parent Node.
//* When John creates a new Node the permission system identifies Role B as a role that would also be able to create the object. Therefore CRUD permissions are assigned in between Role A and B and the newly created object.

Following, we go through all Gentics Mesh objects that can be subject to permissions.  

==== How to grant Permissions on Users

In order to grant permission on individual or all users, one need to specify the path to be either ```/users/:uuid``` or ```/users```, respectively.

Applying permissions on ```/users``` recursively will affect all users.

//COMMENT: This info is interesting for mesh developers, not mesh API users.
// However, applying permissions on ```/users/:uuid``` recursively will have no effect on referenced elements such as node references.

TIP: If you need to grant permission on users of a specific group, please use the ```/groups/:uuid``` element path together with property ```recursively```.

===== Example
The following example shows how to grant the ```Editor Role``` role the permission to read all users. Since this is an operation to be performed on a set of users, the element path ```/users``` needs to be used together with property ```recursive=true```.


NOTE: Links used in the example require prior authentication with user admin (credentials: admin/admin). Please refer to the link:references.html#_authentication[authentication] section to learn about the different authentication mechanisms provided by Gentics Mesh. The https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en[Postman] Chrome extension can be used to build and invoke requests from your browser to Gentics Mesh.

[source,bash]
-----
POST https://demo.getmesh.io/api/v1/roles/6754d83b086244d894d83b086204d87f/permissions/users

BODY
{
  "permissions": {
    "create": false,
    "read": true,
    "update": false,
    "delete": false,
    "publish": false,
    "readPublished": false
  },
  "recursive": true
}

RESPONSE
{
    "message": "Permission for role Editor Role updated."
}
-----

You can query the updated permissions with user ```admin```:

https://demo.getmesh.io/api/v1/roles/6754d83b086244d894d83b086204d87f/permissions/users

===== Role permissions
All possible role permissions on users are summarized in the following table.

[caption=]
.Role permissions on individual users and set of users
[options="header"]
|======
| Role permission       | Element path        | Permission  | Recursive
| Can create new users  | ```/users```        | Create      | false 
| Can read all users    | ```/users```        | Read        | true 
| Can update all users  | ```/users```        | Update      | true 
| Can delete all users  | ```/users```        | Delete      | true 
| Can read user         | ```/users/:uuid```  | Read        | false 
| Can update user       | ```/users/:uuid```  | Update      | false 
| Can delete user       | ```/users/:uuid```  | Delete      | false 
|======

==== How to grant Permissions on Groups

Permissions on a single or multiple groups are applied via ```/groups/:uuid``` path and ```/groups``` path respectively.

* Granting permissions on ```/groups``` recursively will affect all groups.
* Granting permissions  on ```/groups/:uuid``` recursively will affect users of the group.

===== Example
The following example shows how to grant the ```Editor Role``` role the permission to read a specific group (i.e. ```Client Group```) and its users (i.e. ```webclient```). This operation needs to be applied recursively (i.e., ```recursive=true```), otherwise ```read``` permissions would be granted to the group, only.


NOTE: Links used in the example require prior authentication with user admin (credentials: admin/admin). Please refer to the link:references.html#_authentication[authentication] section to learn about the different authentication mechanisms provided by Gentics Mesh. The https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en[Postman] Chrome extension can be used to build and invoke requests from your browser to Gentics Mesh.

[source,bash]
-----
POST https://demo.getmesh.io/api/v1/roles/6754d83b086244d894d83b086204d87f/permissions/groups/df81c23d9ff1450081c23d9ff195005e

BODY
{
  "permissions": {
    "create": false,
    "read": true,
    "update": false,
    "delete": false,
    "publish": false,
    "readPublished": false
  },
  "recursive": true
}

RESPONSE
{
    "message": "Permission for role Editor Role updated."
}
-----

You can query the updated permissions with user ```admin```:

* https://demo.getmesh.io/api/v1/roles/6754d83b086244d894d83b086204d87f/permissions/groups/df81c23d9ff1450081c23d9ff195005e
* https://demo.getmesh.io/api/v1/roles/6754d83b086244d894d83b086204d87f/permissions/users

* or alternatively with
https://demo.getmesh.io/api/v1/groups/df81c23d9ff1450081c23d9ff195005e?role=6754d83b086244d894d83b086204d87f
https://demo.getmesh.io/api/v1/groups/df81c23d9ff1450081c23d9ff195005e/users?role=6754d83b086244d894d83b086204d87f

===== Role permissions
All possible role permissions on groups are summarized in the following table.

[caption=]
.Role permissions on a specific group and multiple groups
[options="header"]
|======
| Role permission        | Element path        | Permission  | Recursive
| Can create new groups  | ```/groups```        | Create      | false 
| Can read all groups    | ```/groups```        | Read        | true 
| Can update all groups  | ```/groups```        | Update      | true 
| Can delete all groups  | ```/groups```        | Delete      | true 
| Can read group         | ```/groups/:uuid```  | Read        | false 
| Can update group       | ```/groups/:uuid```  | Update      | false 
| Can delete group       | ```/groups/:uuid```  | Delete      | false 
| Can read group and its users   | ```/groups/:uuid```| Read        | true 
| Can update group and its users | ```/groups/:uuid```| Update      | true 
| Can delete group and its users | ```/groups/:uuid```| Delete      | true 
|======

==== How to Grant Permissions on Roles

By granting permissions on roles, you effectively grant users the right to change permissions of other users.

* Permissions on a single or multiple roles are applied via ```/roles/:uuid``` path and ```/roles``` path respectively.
* Granting permissions on ```/roles``` recursively will affect all roles.

===== Example
The following example shows how to grant the ```Editor Role``` role permissions to create new roles and subsequently manage them (i.e., ```read```, ```update```, ```delete```) but no access to existing roles. 

NOTE: Links used in the example require prior authentication with user admin (credentials: admin/admin). Please refer to the link:references.html#_authentication[authentication] section to learn about the different authentication mechanisms provided by Gentics Mesh. The https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en[Postman] Chrome extension can be used to build and invoke requests from your browser to Gentics Mesh.

[source,bash]
-----
POST https://demo.getmesh.io/api/v1/roles/6754d83b086244d894d83b086204d87f/permissions/roles

BODY
{
  "permissions": {
    "create": true,
    "read": false,
    "update": false,
    "delete": false,
    "publish": false,
    "readPublished": false
  },
  "recursive": false
}

RESPONSE
{
    "message": "Permission for role Editor Role updated."
}
-----

You can query the updated permissions with user ```admin```:

* https://demo.getmesh.io/api/v1/roles/6754d83b086244d894d83b086204d87f/permissions/roles

* or alternatively with
https://demo.getmesh.io/api/v1/roles?role=6754d83b086244d894d83b086204d87f

===== Role permissions
All possible role permissions on roles are summarized in the following table.

[caption=]
.Role permissions on a specific role and multiple roles
[options="header"]
|======
| Role permission       | Element path        | Permission  | Recursive
| Can create new roles  | ```/roles```        | Create      | false 
| Can read all roles    | ```/roles```        | Read        | true 
| Can update all roles  | ```/roles```        | Update      | true 
| Can delete all roles  | ```/roles```        | Delete      | true 
| Can read role         | ```/roles/:uuid```  | Read        | false 
| Can update role       | ```/roles/:uuid```  | Update      | false 
| Can delete role       | ```/roles/:uuid```  | Delete      | false 
|======

==== How to Grant Permissions on Schemas

Permissions on a single or multiple schemas are applied via ```/schemas/:uuid``` path and ```/schemas``` path respectively.

* Granting permissions on ```/schemas``` recursively will affect all schemas.
* Read permissions on a schema are needed for creating nodes based on that schema.

[caption=]
.Role permissions on a specific schema and multiple schemas
[options="header"]
|======
| Role permission                           | Element path          | Permission  | Recursive
| Can create new schemas                    | ```/schemas```        | Create      | false 
| Can read all schemas, and create nodes    | ```/schemas```        | Read        | true 
| Can update all schemas                    | ```/schemas```        | Update      | true 
| Can delete all schemas                    | ```/schemas```        | Delete      | true 
| Can read schema, and create nodes         | ```/schemas/:uuid```  | Read        | false 
| Can update schema                         | ```/schemas/:uuid```  | Update      | false 
| Can delete schema                         | ```/schemas/:uuid```  | Delete      | false 
|======

==== How to Grant Permissions on Microschemas

Permissions on a single or multiple microschemas are applied via ```/microschemas/:uuid``` path and ```/microschemas``` path respectively.

* Granting permissions on ```/microschemas``` recursively will affect all microschemas.
* Read permissions on a microschema are needed for creating, reading, updating, and deleting micronodes based on that schema.

[caption=]
.Role permissions on a specific microschema and multiple microschemas
[options="header"]
|======
| Role permission                                     | Element path          | Permission  | Recursive
| Can create new microschemas                         | ```/microschemas```        | Create      | false 
| Can read all microschemas, and create micronodes    | ```/microschemas```        | Read        | true 
| Can update all microschemas                         | ```/microschemas```        | Update      | true 
| Can delete all microschemas                         | ```/microschemas```        | Delete      | true 
| Can read microschemas, and create micronodes        | ```/microschemas/:uuid```  | Read        | false 
| Can update microschemas                             | ```/microschemas/:uuid```  | Update      | false 
| Can delete microschemas                             | ```/microschemas/:uuid```  | Delete      | false 
|======


==== How to Grant Permissions on Projects

Permissions on a single or multiple projects are applied via ```/projects/:uuid``` path and ```/projects``` path respectively.

* Granting permissions on ```/projects/:uuid``` will also affect sub elements, i.e., used schemas, microschemas, tagfamilies & tags, nodes & sub nodes of the project.
* Granting permissions on ```/projects``` recursively will affect all projects and their sub elements.

[caption=]
.Role permissions on a specific project and multiple projects
[options="header"]
|======
| Role permission                                      | Element path           | Permission     | Recursive
| Can create new project                               | ```/projects```        | Create         | false 
| Can read all projects and sub elements               | ```/projects```        | Read           | true 
| Can update all projects and sub elements             | ```/projects```        | Update         | true 
| Can delete all projects and sub elements             | ```/projects```        | Delete         | true 
| Can read published nodes and subnodes of all project | ```/projects```        | Read Published | true 
| Can un/publish nodes and subnodes of all project     | ```/projects```        | Publish        | true 
| Can read project and sub elements                    | ```/projects/:uuid```  | Read           | true 
| Can update project and sub elements                  | ```/projects/:uuid```  | Update         | true 
| Can delete project and sub elements                  | ```/projects/:uuid```  | Delete         | true 
| Can read published nodes and subnodes of project     | ```/projects/:uuid```  | Read Published | true 
| Can un/publish nodes and subnodes of project         | ```/projects/:uuid```  | Publish        | true 
|======

==== How to Grant Permissions on Tag Families

In order to grant permission on tag families the ```/:projectName/tagFamilies``` path can be used.

* Granting permissions on ```/:projectName/tagFamilies/:uuid```  together with property ```recursive=true``` allows setting permissions for tags of a tag family.
* Granting permissions on ```/:projectName/tagFamilies```  together with property ```recursive=true``` allows setting permissions for all tag families and their tags.

[caption=]
.Role permissions on tag families
[options="header"]
|======
| Role permission                                      | Element path                           | Permission     | Recursive
| Can create new tag families                          | ```/:projectName/tagFamilies```        | Create         | false 
| Can create new tag families and tags for tagFamilies | ```/:projectName/tagFamilies```        | Create         | true 
| Can read all tag families and tags                   | ```/:projectName/tagFamilies```        | Read           | true 
| Can update all tag families and tags                 | ```/:projectName/tagFamilies```        | Update         | true 
| Can delete all tag families and tags                 | ```/:projectName/tagFamilies```        | Delete         | true 
| Can create tags in tag family                        | ```/:projectName/tagFamilies/:uuid```  | Create         | false 
| Can read tag family                                  | ```/:projectName/tagFamilies/:uuid```  | Read           | false 
| Can update tag family                                | ```/:projectName/tagFamilies/:uuid```  | Update         | false 
| Can delete tag family                                | ```/:projectName/tagFamilies/:uuid```  | Delete         | false 
| Can read tag family and tags                         | ```/:projectName/tagFamilies/:uuid```  | Read           | true 
| Can update tag family and tags                       | ```/:projectName/tagFamilies/:uuid```  | Update         | true 
| Can delete tag family and tags                       | ```/:projectName/tagFamilies/:uuid```  | Delete         | true 
|======

==== How to Grant Permissions on Tags

In order to grant permission on tags the ```/:projectName/tagFamilies/:uuid/tags``` and ```/:projectName/tagFamilies/:uuid/tags/:uuid``` paths can be used.

* Granting permissions on ```/:projectName/tagFamilies/:uuid/tags``` together with property ```recursive=true``` allows setting permissions for tags of a tag family, otherwise the property has no effect.

[caption=]
.Role permissions on tag families
[options="header"]
|======
| Role permission                | Element path                                     | Permission     | Recursive
| Can create tags in tag family  | ```/:projectName/tagFamilies/:uuid/tags```       | Create         | false 
| Can read tags in tag family    | ```/:projectName/tagFamilies/:uuid/tags```       | Read           | true 
| Can update tags in tag family  | ```/:projectName/tagFamilies/:uuid/tags```       | Update         | true 
| Can delete tags in tag family  | ```/:projectName/tagFamilies/:uuid/tags```       | Delete         | true 
| Can read tag                   | ```/:projectName/tagFamilies/:uuid/tags/:uuid``` | Read           | false 
| Can update tag                 | ```/:projectName/tagFamilies/:uuid/tags/:uuid``` | Update         | false 
| Can delete tag                 | ```/:projectName/tagFamilies/:uuid/tags/:uuid``` | Delete         | false 
|======

==== How to Grant Permissions on Nodes

Permissions on a single or multiple nodes are applied via ```/:projectName/nodes``` and ```/:projectName/nodes/:uuid``` path:

* ```/:projectName/nodes/:uuid``` is used to grant permissions on single nodes. 
* ```/:projectName/nodes``` together with property ```recursive=true``` can be used to quickly grant permissions on all node of the project.
* In order to grant permissions on sub trees of the content tree ```/:projectName/nodes/:uuid``` together with property ```recursive=true``` is to be used.

[caption=]
.Role permissions on nodes
[options="header"]
|======
| Role permission                                           | Element path                    | Permission    | Recursive
| Can create new sub nodes in all nodes of the project      | ```/:projectName/nodes```       | Create        | true 
| Can read all project nodes (and all node versions)        | ```/:projectName/nodes```       | Read          | true 
| Can update all nodes of the project                       | ```/:projectName/nodes```       | Update        | true 
| Can delete all nodes of the project                       | ```/:projectName/nodes```       | Delete        | true 
| Can read the published version of all project nodes       | ```/:projectName/nodes```       | ReadPublished | true 
| Can publish/unpublish all nodes of the project            | ```/:projectName/nodes```       | Publish       | true 
| Can create new sub nodes in specified node                | ```/:projectName/nodes/:uuid``` | Create        | false 
| Can read specified node                                   | ```/:projectName/nodes/:uuid``` | Read          | false 
| Can update specified node                                 | ```/:projectName/nodes/:uuid``` | Update        | false 
| Can delete specified node                                 | ```/:projectName/nodes/:uuid``` | Delete        | false 
| Can read the published version specified node             | ```/:projectName/nodes/:uuid``` | ReadPublished | false 
| Can publish/unpublish specified node                      | ```/:projectName/nodes/:uuid``` | Publish       | false 
| Can create new sub nodes in specified node & sub nodes    | ```/:projectName/nodes/:uuid``` | Create        | true 
| Can read specified node & sub nodes                       | ```/:projectName/nodes/:uuid``` | Read          | true 
| Can update specified node & sub nodes                     | ```/:projectName/nodes/:uuid``` | Update        | true 
| Can delete specified node & sub nodes                     | ```/:projectName/nodes/:uuid``` | Delete        | true 
| Can read the published version specified node & sub nodes | ```/:projectName/nodes/:uuid``` | readPublished | true 
| Can publish/unpublish specified node & sub nodes          | ```/:projectName/nodes/:uuid``` | Publish       | true 

|======


==== How to Grant Permissions on Releases

Permissions on a single or multiple releases are applied via ```/releases/:uuid``` path and ```/releases``` path respectively.

NOTE: Releases can not be deleted. Hence, permissions for deleting do not apply.

[caption=]
.Role permissions on a specific release and multiple releases
[options="header"]
|======
| Role permission                     | Element path                        | Permission     | Recursive
| Can create new release              | ```/:projectName/releases```        | Create         | false 
| Can read all releases               | ```/:projectName/releases```        | Read           | true 
| Can update all releases             | ```/:projectName/releases```        | Update         | true 
| Can read the release                | ```/:projectName/releases/:uuid```  | Read           | false 
| Can update the release              | ```/:projectName/releases/:uuid```  | Update         | false 
|======


== Versioning

In order to understand the concept of versioning in Gentics Mesh it is important to remember that nodes are containers for language variants (see <<multilanguage, Multi-Language>>). The language variant of a node contains the fields and thus stores all the content.

NOTE: Versioning within Gentics Mesh only applies to *language variants* and their referenced fields. Other elements such as users, groups, roles, permissions and even nodes are not versioned.

Various content management tasks will have different effects for versioning in Gentics Mesh. Some of them create versions, others don't. Following, we go through all of these actions which involve versioning.

NOTE: At the moment it is not possible to delete older versions.

=== Node Creation

Once a node has been created the initial version 0.1 will be assigned to its language variant.

=== Node Updates

Updating a node's language variant may create a minor version 0.2 of that language variant if changes have been detected within the posted request fields.

*No Locks:*

It is not required to handle locks in Gentics Mesh. Instead it is required to specify the version in the update request which identifies the version on which the update request was based upon.

*Conflict detection:*

Gentics Mesh will check whether new versions have been created in the meanwhile. Long running edit operations or multiple concurrent editors may create additional versions.

The detected changes will be compared automatically in order to determine whether the current update request causes a conflict with a newer edit request.
Gentics Mesh will return a response which contains information about the conflict in those cases. Other update operations which do not cause a conflict will be stored and the changed fields will be updated.

The latest version which was created using an update request is called the ```draft``` version. Only a single draft version per language variant exists.

=== Publishing Nodes

Node language variants can be published and taken offline. This is particularly useful if you want to first work on a draft, then review it and publish it at a later point in time.

Publishing requires a ```POST``` request on the ```/api/v1/:projectName/nodes/:uuid/published``` endpoint, which will publish all language variants of the node.
It is also possible to just publish specific language variants with dedicated ```POST``` requests on ```/api/v1/:projectName/nodes/:uuid/languages/:languageTag/published```.

Gentics Mesh will automatically create a new major version when publishing a node language variant (e.g.: 1.0, 2.0). The ```draft``` reference will also be updated to point to the major version, e.g. 1.0.

Furthermore, it is possible to retrieve information about the published status via a ```GET``` request on ```/api/v1/:/nodes/:uuid/published```.

NOTE: Publishing node language variants requires the user to be assigned to a group with a role which provides the ```publish``` permission.

[source,json]
----
include::examples/api/response/api/v1/\{project\}/nodes/\{nodeUuid\}/published/200/example.json[]
----

NOTE: It is not possible to publish a specific version. Publish always affects the latest draft version of the language variant.

=== Taking Nodes Offline

Similarly to publishing, the language variants of a node can be taken offline via a ```DELETE``` request on ```/api/v1/:projectName/nodes/:uuid/published```.
E.g., taking a specific node language variant with version 1.0 offline using ```DELETE /api/v1/:projectName/nodes/:uuid/languages/:languageTag/published``` will just change the node's publish state. Version 1.0 will still be available.

NOTE: Taking node language variants offline requires the user have ```publish``` permissions on the node.

===  Reading Nodes

It is possible to fetch older versions by specifying the ```?version``` query parameter. Similarly, the published version of a node language variant can also be loaded using the parameter ```?version=published``` or the draft version via ```?version=draft```.

IMPORTANT: Gentics Mesh by default returns the ```draft``` version of nodes. This means for supporting the ```anonymous``` user and public content, you need to add the ```?version=published``` query parameter on all requests for nodes to avoid _"Missing permissions on object"_ errors.

NOTE: Reading published nodes requires the user to be assigned to a role which grants the ```readPublished``` permission.

== Content Releases

So far we learned that node language variants can be versioned and published. Additionally Mesh versioning provides a powerful concept we call `Releases`. A release is very similar to branches in a versioning control system.

Releases can be used to restructure your nodes and change the contents within a specific release without affecting a different release which provides a different structure/content.

Structural references for nodes always contain release information. This applies to parent/child relationship or taggings, publish states of nodes. This way releases are completely isolated from each other.

NOTE: It is currently not possible to migrate from one release to another. Nodes of releases can't be automatically merged to other releases.

Typical usecases are:

* Updating an existing application installation which uses Gentics Mesh to a new version. The new application version requires new schema versions.
  By creating a release and migrating the nodes to the new release (new schema versions), it is possible to serve content for both application versions.
  Each application versions chooses the correct release for getting nodes.

* Schema versions must be assigned to the release.
  Each project can have multiple releases.
  An initial release will automatically be created when creating a project.

All operations to nodes can be scoped to a specific release by adding the ```?release=name``` query parameter. If omitted the latest release will be used to execute the operation.

TIP: Implementations which use mesh should always reference a specific release. Otherwise the document structure could change without the implementation being aware of these changes.

=== Creating a Release

A release requires an unique name. Existing nodes within the project will automatically be migrated into the release.
Please note the started *node migration* will be processed asynchronously and thus not all nodes may be directly accessible within the scope of the release.

This migration is different from a schema version migration. The release node migration just takes care of making all nodes from the previous release available in the newly created release.
Unlike the schema migration the node migration will not create new language variant versions.

You can use the eventbus bridge or the dedicated ```/api/v1/admin/status/migrations``` endpoint to query the migration status.
The ```migrated``` JSON property within the release response also indicates whether the node migration has been completed.

Note: Migrated nodes will still have the same _uuid_ as before.

=== Updating a Release

A release can be _renamed_ and new schema/microschema versions can be _assigned_ to it.

Renaming is useful if you want to change your development release to be the current production release.

Assigning schema versions to the release via a ```PUT``` request to ```/api/v1/:projectName/releases/:uuid/schemas``` will automatically trigger a schema migration of the affected nodes language variants within the release.

[source,json]
----
include::examples/api/request/api/v1/\{project\}/releases/\{releaseUuid\}/schemas/request-body.json[]
----

It is also possible to assign microschemas via a ```PUT``` request to ```/api/v1/:projectName/releases/:uuid/microschemas``` to the release.

[source,json]
----
include::examples/api/request/api/v1/\{project\}/releases/\{releaseUuid\}/microschemas/request-body.json[]
----

All nodes which reference the release via the updated schema version will automatically be migrated to use the newer schema version.
Please note the started *schema migration* will be processed asynchronously and thus not all node language variants may be directly accessible within the scope of the release.

The migration will create new versions for the affected node language variants.

NOTE: It is note worthy that updating a schema and thus creating new schema version will not automatically affect the release. Each schema update created a new schema version. This new version must first be assigned to the release.

=== Deleting a Release

At the moment it is not possible to delete a release.

=== Moving Nodes

Releases enable Gentics Mesh to setup multiple content project tree structures.
Moving nodes can be scoped to a specific release using the ```?release``` request parameter.
The project's initial release will be used to execute the move operation if no release has been selected.

=== Tagging Nodes

The tag operation is also scoped to a specific release. This way new tags can be assigned to your nodes for a specific release without affecting the taggings of nodes within an older release.

NOTE: Tags and tag families are not versioned. Deleting a tag will remove the tag from all nodes that previously referenced this tag.

NOTE: Taggings to nodes are not versioned.

=== Deleting Nodes

Deleting nodes is also release specific. Deleting a node via ```DELETE``` to ```/api/v1/:projectName/node/:uuid?release=winter2016``` will delete the node and all its sub nodes from the _winter2016_ release.
The node will be completely removed from the system if no more language variants are referenced within any release.

It is also possible to just delete a specific language variant via ```DELETE``` to ```/api/v1/:projectName/node/:uuid/languages/en?release=winter2016``` from release _winter2016_.

=== Updating Nodes

Releases are completely isolated from each other as explained earlier. This also applies to a node's language variant versions.

Example:

* Create release _summer2016_
* Create node with language variant _de_ at version _1.0_ in release _summer2016_
* Create release _winter2016_
* Update previously created node in release _summer2016_ and thus create version _1.1_

Release _summer2016_ will reference node language variant 1.1 and _winter2016_ will still reference version 1.0 since the _winter2016_ release was created at the specific point of time in which the language variant in release _summer2016_ was still at version _1.0_.

NOTE: It is currently not possible to migrate _1.1_ from _summer2016_ to _winter2016_.

Additionally creating new nodes in _summer2016_ will not be available in release _winter2016_.

=== Permissions

NOTE: Permissions are not release specific.

== Search

Search requests are handled by the ```/api/v1/search``` or ```/api/v1/:projectName/search``` endpoints.

Elasticsearch is used in order to provide the search functionality. This way elasticsearch queries can be posted to the search endpoints.

The JSON format of stored documents within the elasticsearch differ from the JSON format that is returned via regular Gentics Mesh endpoints. Thus it is important to know the elasticsearch document format when building an elasticsearch query. Below is a list of various example documents.

NOTE: It is not possible to search for specific individual versions. Instead only published and draft versions per release are stored in the search index.

=== Users

Endpoint: ```/api/v1/search/users```

[source,json]
----
include::examples/search/user.search.json[]
----

=== Groups

Endpoint: ```/api/v1/search/groups```

[source,json]
----
include::examples/search/group.search.json[]
----


=== Roles

Endpoint: ```/api/v1/search/roles```

[source,json]
----
include::examples/search/role.search.json[]
----

=== Nodes

Endpoint: ```/api/v1/search/nodes```

[source,json]
----
include::examples/search/node.search.json[]
----


*Search nodes by schema name*

Listed below is an example search query which can be posted to ```/api/v1/search/nodes``` in order to find all nodes across all projects which were created using the content schema.
The found nodes will be sorted ascending by creator.

[source,json]
----
{
  "sort" : {
     "created" : { "order" : "asc" }
  },
  "query":{
    "bool" : {
      "must" : {
        "term" : { "schema.name" : "content" }
       }
    }
  }
}
----



*Search nodes by micronode field values*

Find all nodes which have a micronode list field (vcardlist) that contain at least one micronode which contains the two string fields (firstName, lastName) with the values ("Joe", "Doe"):

[source,json]
----
{
  "query": {
    "nested": {
      "path": "fields.vcardlist",
      "query": {
        "bool": {
          "must": [
            {
              "match": {
                "fields.vcardlist.fields.firstName": "Joe"
              }
            },
            {
              "match": {
                "fields.vcardlist.fields.lastName": "Doe"
              }
            }
          ]
        }
      }
    }
  }
}
----

*Search nodes which are tagged 'Solar' and 'Blue'*

The tags field is a nested field and thus a nested query must be used to match the two tags. Please note that you need to use `match_phrase` because you want to match the whole tag name. Using `match` would cause elasticsearch to match any of trigram found within the tag name value. 

[source,json]
----
{
  "query": {
    "nested": {
      "path": "tags",
      "query": {
        "bool": {
          "must": [
            {
              "match_phrase": {
                "tags.name": "Solar"
              }
            },
            {
              "match_phrase": {
                "tags.name": "Blue"
              }
            }
          ]
        }
      }
    }
  }
}
----



=== Projects

Endpoint: ```/api/v1/search/projects```

[source,json]
----
include::examples/search/project.search.json[]
----

=== Tags

Endpoint: ```/api/v1/search/tags```

[source,json]
----
include::examples/search/tag.search.json[]
----

=== Tag Families

Endpoint: ```/api/v1/search/tagFamilies```

[source,json]
----
include::examples/search/tagFamily.search.json[]
----

=== Schemas

Endpoint: ```/api/v1/search/schemas```

[source,json]
----
include::examples/search/schema.search.json[]
----

=== Microschemas

Endpoint: ```/api/v1/search/microschemas```

[source,json]
----
include::examples/search/microschema.search.json[]
----


=== Paging

The paging query parameters are `perPage` and `page` . It is important to note that ```page``` is 1-based and ```perPage``` can be set to ```0``` in order to just retrieve a count of elements.

== Preview Handling

The Gentics Mesh User Interface provides a preview button when editing nodes. A post request to a configureable url is being dispatched when the button is triggered.
The post request will contain the node JSON data of the current editing state. This way a preview page can be easily rendered by custom frontend implementations.

== Password Recovery

A user who lost his password is able to recover it using a reset token. This token, typically, is issued by a user or service having permissions to create new users.
The ```/api/v1/users/:userUuid/reset_token``` endpoint will return a token code which then can be passed along to an email service sending a recovery email to the user including named token.

NOTE: A token is valid for 30 minutes and will be invalidated once it has been used.

The user can use this token to update his user record by issuing a POST request to the ```/api/v1/users/:userUuid?token=TOKENCODE``` endpoint. E.g., this can be done by presenting the user a form for updating his password. This works even if the user is not authenticated.

== Schema & Microschema Migration

Gentics Mesh provides a changelog like system in order to apply and keep track of schema changes. A schema change may be a single change that adds a new field to the schema or a change which updates the schema properties.

Gentics Mesh supports the following change operations:

=== Operation: addfield

[options="header"]
|======
| Properties  | Description
| after       | Name of the field after which the new field should be inserted
| field       | Name of the field that should be added
| type        | Type of the field
| listType    | Optional list type
|======


[source,json]
----
include::examples/models/addfield.json[]
----


=== Operation: removefield

[options="header"]
|======
| Properties  | Description
| field       | Name of the field to be removed
|======

[source,json]
----
include::examples/models/removefield.json[]
----


=== Operation: changefieldtype

[options="header"]
|======
| Properties  | Description
| field       | Name of the field to be modified
| type        | New field type
| listType    | (Only applies for lists) New list type
|======

[source,json]
----
include::examples/models/changefieldtype.json[]
----

=== Operation: updatefield

[options="header"]
|======
| Properties       | Description
| field            | Field to be updated
| label            | New field label
|======

[source,json]
----
include::examples/models/updatefield.json[]
----

=== Operation: updateschema

[options="header"]
|======
| Properties       | Description
| description      | New schema description
| order            | Array of strings that contains the field order
| displayFieldname | New displayFieldname value of the schema
| segmentFieldname | New segmentFieldname value of the schema
| container        | New container flag of the schema
|======

[source,json]
----
include::examples/models/updateschema.json[]
----

=== Operation: updatemicroschema

[options="header"]
|======
| Properties       | Description
| description      | New microschema description
|======

[source,json]
----
include::examples/models/updatemicroschema.json[]
----

Each change may also provide a migration script. The migration script can be used to modify nodes that were affected by the migration.

Typical usecases for migration scripts are for example dynamic field removal or even custom reformatting of field data.
It is also possible to split a single field value into values for two new fields.

The ```/api/v1/schemas/:uuid/diff``` and ```/api/v1/microschemas/:uuid/diff``` endpoints can be used to generate a list of changes by comparing the stored and posted schema.

This list of changes can be modified and posted to ```/api/v1/schemas/:uuid/changes``` for schemas or ```/api/v1/microschemas/:uuid/changes``` for microschemas.
The posted list of changes will be validated and stored when valid. A schema migration process will be started which runs in the background.

The https://github.com/sockjs[SockJS] compliant ```/api/v1/eventbus``` endpoint can be used to register to migration specific messages.

Additionally to websocket it is possible to query whether a migration is running via the ```/api/v1/admin/status/migrations``` endpoint.

Sending a schema to ```/api/v1/schemas:uuid``` using the ```PUT``` method will conveniently combine the diff generation and invocation of the schema migration.

Please note that by default conflicting data will be *removed* and this action can only be avoided by specifying a custom migration script.

=== Custom Migration Scripts

Sometimes it is desired to overwrite the default migration behaviour.

The following migration script converts the number value from field ```node.fields[fieldname]``` into a _ISO-8601_ date string which is then stored within the ```node.fields[fieldname]``` field.

[source,javascript]
----
function migrate(node, fieldname, convert) {
    node.fields[fieldname] = new Date(new Date(node.fields[fieldname]).getTime() + 864000).toISOString();
    return node;
}
----

Migration scripts also allow you to split up a field value into two different fields.

[source,javascript]
----
function migrate(node, fieldname, convert) {
    node.fields["fieldA"] = "First field set";
    node.fields["fieldB"] = "Second field set";
    return node;
}
----

The provided converter can be used to convert in between field types. This converter will be used if no custom migration script was specified.


[source,javascript]
----
function migrate(node, fieldname, convert) {
    var stringValue = convert.toString(node.fields[fieldname]);

    // It is important to use the Java.from method to convert the java list object into a number array.
    var numberArray    = Java.from(convert.toNumberList(node.fields[fieldname]));
    var micronodeArray = Java.from(convert.toMicronodeList(node.fields[fieldname]));
    var dateArray      = Java.from(convert.toDateList(node.fields[fieldname]));
    var booleanArray   = Java.from(convert.toBooleanList(node.fields[fieldname]));

    var numberValue    = convert.toNumber(node.fields[fieldname]);
    var nodeValue      = convert.toNode(node.fields[fieldname]);
    var micronodeValue = convert.toMicronode(node.fields[fieldname]);
    var dateValue      = convert.toDate(node.fields[fieldname]);
    var booleanValue   = convert.toBoolean(node.fields[fieldname]);
    var binaryValue    = convert.toBinary(node.fields[fieldname]);

    // Delete the field
    delete node.fields[fieldname];
    return node;
}
----


Finally the changes can be applied by sending the request to ```/api/v1/schemas/:uuid/changes```.

[source,json]
----
include::examples/api/request/api/v1/schemas/\{schemaUuid\}/changes/request-body.json[]
----

== Eventbus Bridge & Websocket

The ```/api/v1/eventbus``` endpoint allows clients to access the eventbus. This may be useful if you want to react on specific events.
Currently only schema migration specific events are handled via this endpoint but more will follow.

The endpoint is https://github.com/sockjs[SockJS]  compliant. It is also possible to access the websocket directly via: ```/api/v1/eventbus/websocket```.

[options="header"]
|======
| Eventname       | Description
| mesh.migration  | Receive node and micronode migration specific events
|======

== Clustering

Clustering support is still in development.

It will be possible to use master/master replication for OrientDB. Clustering for the Elasticsearch nodes and the Vert.x event message bus.
