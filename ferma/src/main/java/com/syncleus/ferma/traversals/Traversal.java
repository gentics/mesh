/**
 * Copyright 2004 - 2016 Syncleus, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Part or all of this source file was forked from a third-party project, the details of which are listed below.
 *
 * Source Project: Totorom
 * Source URL: https://github.com/BrynCooke/totorom
 * Source License: Apache Public License v2.0
 * When: November, 20th 2014
 */
package com.syncleus.ferma.traversals;

import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.syncleus.ferma.EdgeFrame;
import com.syncleus.ferma.VertexFrame;
import com.tinkerpop.gremlin.Tokens;
import com.tinkerpop.gremlin.java.GremlinPipeline;
import com.tinkerpop.pipes.transform.TransformPipe;

/**
 * The root traversal class. Wraps a Tinkerpop {@link GremlinPipeline}
 *
 * @param <T>
 *            The type of the objects coming off the pipe.
 * @param <C>
 *            The cap of the current pipe.
 * @param <S>
 *            The SideEffect of the current pipe.
 * @param <M>
 *            The current marked type for the current pipe.
 */
public interface Traversal<T, C, S, M> extends Iterator<T>, Iterable<T> {

	/**
	 * Traverse over all the vertices in the graph.
	 * 
	 * @return The traversal representing all vertices in the graph.
	 */
	VertexTraversal<?, ?, M> v();

	/**
	 * Traverse over all the edges in the graph.
	 * 
	 * @return The traversal representing all the edges in the graph.
	 */
	EdgeTraversal<?, ?, M> e();

	/**
	 * Traverse over all the vertices in the graph that have the specified key and value.
	 *
	 * @param key
	 *            The property key to filter for.
	 * @param value
	 *            The property value to filter for.
	 * @return the traversal
	 */
	VertexTraversal<?, ?, M> v(String key, Object value);

	/**
	 * Completely drain the pipeline of its objects. Useful when a sideEffect of the pipeline is desired.
	 */
	void iterate();

	/**
	 * Will only emit the object if it has not been seen before.
	 *
	 * @return the extended Pipeline
	 */
	Traversal<T, ?, ?, M> dedup();

	/**
	 * Will only emit the object if the object generated by its function hasn't been seen before.
	 *
	 * @param dedupFunction
	 *            a function to call on the object to yield the object to dedup on
	 * @return the extended Pipeline
	 */
	Traversal<T, ?, ?, M> dedup(TraversalFunction<T, ?> dedupFunction);

	/**
	 * Will only emit the object if it is not in the provided collection.
	 *
	 * @param collection
	 *            the collection except from the stream
	 * @return the extended Pipeline
	 */
	Traversal<T, ?, ?, M> except(Iterable<?> collection);

	/**
	 * Will only emit the object if it is not equal to any of the objects contained at the named steps.
	 *
	 * @param namedSteps
	 *            the named steps in the pipeline
	 * @return the extended Pipeline
	 */
	Traversal<T, ?, ?, M> except(String... namedSteps);

	/**
	 * The serves are an arbitrary filter where the filter criteria is provided by the filterFunction.
	 *
	 * @param filterFunction
	 *            the filter function of the pipe
	 * @return the extended Pipeline
	 */
	Traversal<T, ?, ?, M> filter(TraversalFunction<T, Boolean> filterFunction);

	/**
	 * Will emit the object only if it is in the provided collection.
	 *
	 * @param collection
	 *            the collection to retain
	 * @return the extended Pipeline
	 */
	Traversal<T, ?, ?, M> retain(Iterable<?> collection);

	/**
	 * Will only emit the object if it is equal to any of the objects contained at the named steps.
	 *
	 * @param namedSteps
	 *            the named steps in the pipeline
	 * @return the extended Pipeline
	 */
	Traversal<T, ?, ?, M> retain(String... namedSteps);

	/**
	 * The objects prior to aggregate are greedily collected into an ArrayList.
	 *
	 * @return the extended Pipeline
	 */
	Traversal<T, Collection<? extends T>, Collection<? extends T>, M> aggregate();

	/**
	 * The objects prior to aggregate are greedily collected into the provided collection.
	 *
	 * @param aggregate
	 *            the collection to aggregate results into
	 * @return the extended Pipeline
	 */
	Traversal<T, Collection<? extends T>, Collection<? extends T>, M> aggregate(Collection<? super T> aggregate);

	/**
	 * The results of the function evaluated on the objects prior to the aggregate are greedily collected into the provided collection.
	 *
	 * @param <N>
	 *            The type resulting from the aggregation.
	 * @param aggregate
	 *            the collection to aggregate results into
	 * @param aggregateFunction
	 *            the function to run over each object prior to insertion into the aggregate
	 * @return the extended Pipeline
	 */
	<N> Traversal<T, Collection<? extends N>, Collection<? extends N>, M> aggregate(Collection<? super N> aggregate,
		TraversalFunction<T, ? extends N> aggregateFunction);

	/**
	 * The results of the function evaluated on the objects prior to the aggregate are greedily collected into an ArrayList.
	 *
	 * @param <N>
	 *            The type resulting from the aggregation.
	 * @param aggregateFunction
	 *            the function to run over each object prior to insertion into the aggregate
	 * @return the extended Pipeline
	 */
	<N> Traversal<T, Collection<? extends N>, Collection<? extends N>, M> aggregate(TraversalFunction<T, ? extends N> aggregateFunction);

	/**
	 * The provided function is evaluated and the incoming object is the outgoing object.
	 *
	 * @param sideEffectFunction
	 *            the function of the pipe
	 * @return the extended Pipeline
	 */
	Traversal<T, ?, ?, M> sideEffect(SideEffectFunction<T> sideEffectFunction);

	/**
	 * Useful in various situations where a step is needed without processing. For example, useful when two as-steps are needed in a row.
	 *
	 * @return the extended Pipeline
	 */
	Traversal<T, ?, ?, M> identity();

	/**
	 * This step will hold a Map of the objects that have entered into its pipeline section. If an input is seen twice, then the map stored output is emitted
	 * instead of recomputing the pipeline section.
	 *
	 * @param namedStep
	 *            the name of the step previous to memoize to
	 * @return the extended Pipeline
	 */
	Traversal<T, ?, ?, M> memoize(String namedStep);

	/**
	 * This step will hold a Map of the objects that have entered into its pipeline section. If an input is seen twice, then the map stored output is emitted
	 * instead of recomputing the pipeline section.
	 *
	 * @param namedStep
	 *            the name of the step previous to memoize to
	 * @param map
	 *            the memoization map
	 * @return the extended Pipeline
	 */
	Traversal<T, ?, ?, M> memoize(String namedStep, Map<?, ?> map);

	/**
	 * This step will sort the objects in the stream in a default Comparable order.
	 *
	 * @return the extended Pipeline
	 */
	Traversal<T, ?, ?, M> order();

	/**
	 * This step will sort the objects in the stream in a default Comparable order.
	 *
	 * @param order
	 *            if the stream is composed of comparable objects, then increment or decrement can be specified
	 * @return the extended Pipeline
	 */
	Traversal<T, ?, ?, M> order(TransformPipe.Order order);

	/**
	 * This step will sort the objects in the stream in a default Comparable order.
	 *
	 * @param order
	 *            if the stream is composed of comparable objects, then increment or decrement can be specified
	 * @return the extended Pipeline
	 */
	Traversal<T, ?, ?, M> order(Tokens.T order);

	/**
	 * This step will sort the objects in the stream according to a comparator defined in the provided function.
	 *
	 * @param compareFunction
	 *            a comparator function of two objects of type e
	 * @return the extended Pipeline
	 */
	Traversal<T, ?, ?, M> order(Comparator<? super T> compareFunction);

	/**
	 * The object that was seen at the topmost marked step is emitted. The mark step is removed from the stack.
	 *
	 * @return the extended Pipeline
	 */
	M back();

	/**
	 * Marks the step so that a subsequent call to back() or optional() may return to this point. If the pipeline is a stack then each call to back or optional
	 * will pop all steps back to and including the previous mark. The next mark in the pipeline is thus exposed.
	 * 
	 * @return the extended Pipeline
	 */
	Traversal<T, C, S, ? extends Traversal<T, C, S, M>> mark();

	/**
	 * When the previous step in the pipeline is implements SideEffectPipe, then it has a method called getSideEffect(). The cap step will greedily iterate the
	 * pipeline and then, when its empty, emit the side effect of the previous pipe.
	 *
	 * @return the extended Pipeline
	 */
	C cap();

	/**
	 * Given an input, the provided function is computed on the input and the output of that function is emitted.
	 *
	 * @param <N>
	 *            The type to transform into.
	 * @param function
	 *            the transformation function of the pipe
	 * @return the extended Pipeline
	 */
	<N> Traversal<? extends N, ?, ?, M> transform(TraversalFunction<T, N> function);

	/**
	 * Though, in practice, a StartPipe is usually the beginning. Moreover, the constructor of the Pipeline will internally use StartPipe.
	 *
	 * @param <N>
	 *            The type of the object flowing through this pipe
	 * @param object
	 *            the object that serves as the start of the pipeline (iterator/iterable are unfolded)
	 * @return the extended Pipeline
	 */
	<N> Traversal<N, ?, ?, M> start(N object);

	/**
	 * Though, in practice, a StartPipe is usually the beginning. Moreover, the constructor of the Pipeline will internally use StartPipe.
	 *
	 * @param object
	 *            the object that serves as the start of the pipeline (iterator/iterable are unfolded)
	 * @return the extended Pipeline
	 */
	VertexTraversal<?, ?, M> start(VertexFrame object);

	/**
	 * Though, in practice, a StartPipe is usually the beginning. Moreover, the constructor of the Pipeline will internally use StartPipe.
	 *
	 * @param object
	 *            the object that serves as the start of the pipeline (iterator/iterable are unfolded)
	 * @return the extended Pipeline
	 */
	EdgeTraversal<?, ?, M> start(EdgeFrame object);

	/**
	 * Emit the respective property of the incoming element.
	 *
	 * @param <N>
	 *            The type of the property value
	 * @param key
	 *            the property key
	 * @return the extended Pipeline
	 */
	<N> Traversal<N, ?, ?, M> property(String key);

	/**
	 * Emit the respective property of the incoming element.
	 *
	 * @param <N>
	 *            The type of the property value
	 * @param key
	 *            the property key
	 * @param type
	 *            the property type;
	 * @return the extended Pipeline
	 */
	<N> Traversal<? extends N, ?, ?, M> property(String key, Class<N> type);

	/**
	 * Return the number of objects iterated through the pipeline.
	 *
	 * @return the number of objects iterated
	 */
	long count();

	/**
	 * Return the next object in the pipeline.
	 *
	 */
	@Override
	T next();

	/**
	 * Return the next object in the pipeline.
	 *
	 * @param defaultValue
	 *            The value to be returned if there is no next object in the pipeline.
	 * @return returns the next object in the pipeline, if there are no more objects then defaultValue is returned.
	 */
	T nextOrDefault(T defaultValue);

	/**
	 * Return the next X objects in the pipeline as a list.
	 *
	 * @param number
	 *            the number of objects to return
	 * @return a list of X objects (if X objects occur)
	 */
	@Deprecated
	List<? extends T> next(int number);

	/**
	 * Return a list of all the objects in the pipeline.
	 *
	 * @return a list of all the objects
	 */
	@Deprecated
	List<? extends T> toList();

	/**
	 * Enable path calculations within the Pipeline. This is typically done automatically and in rare occasions needs to be called.
	 *
	 * @return the Pipeline with path calculations enabled
	 */
	Traversal<T, C, S, M> enablePath();

	/**
	 * Fill the provided collection with the objects in the pipeline.
	 *
	 * @param collection
	 *            the collection to fill
	 * @return the collection filled
	 */
	Collection<? extends T> fill(Collection<? super T> collection);

	/**
	 * Emit the ids of the incoming objects.
	 *
	 * @param <N>
	 *            The type of the id objects.
	 * @return A traversal of the ids.
	 * @since 2.1.0
	 */
	<N> Traversal<N, ?, ?, M> id();

	/**
	 * Emit the ids of the incoming objects, cast to the specified class.
	 *
	 * @param <N>
	 *            The type of the id objects.
	 * @param c
	 *            the class type to cast the ids to.
	 * @return A traversal of the ids.
	 * @since 2.1.0
	 */
	<N> Traversal<? extends N, ?, ?, M> id(Class<N> c);
}
